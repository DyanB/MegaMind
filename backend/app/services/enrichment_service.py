from typing import List, Dict, Optional
from .search_providers import SearchProvider, ExaSearch, WikipediaSearch


class EnrichmentService:
    """Service to orchestrate external source enrichment with fallback strategy"""
    
    def __init__(
        self, 
        providers: Optional[List[SearchProvider]] = None
    ):
        """
        Initialize with search providers in priority order
        
        Args:
            providers: List of SearchProvider instances (Exa first, Wiki fallback by default)
        """
        if providers is None:
            # Default: Exa first, Wikipedia fallback
            self.providers = [
                ExaSearch(),
                WikipediaSearch()
            ]
        else:
            self.providers = providers
        
        # Log available providers
        available = [p.__class__.__name__ for p in self.providers if p.is_available()]
        if available:
            print(f"Enrichment providers available: {', '.join(available)}")
        else:
            print("WARNING: No enrichment providers available")
    
    def auto_enrich(self, search_queries: List[str]) -> Dict:
        """
        Fetch external sources using fallback strategy
        
        Strategy: Try each provider in order until results are found
        - First try Exa (neural search, high quality)
        - Fallback to Wikipedia (free, reliable)
        
        Args:
            search_queries: List of search terms generated by LLM
            
        Returns:
            Dictionary with enrichment results
        """
        all_sources = []
        queries_attempted = []
        seen_urls = set()  # Track normalized URLs to deduplicate
        
        def normalize_url(url: str) -> str:
            """Normalize URL for deduplication"""
            # Remove protocol
            url = url.replace('https://', '').replace('http://', '')
            # Remove trailing slash
            url = url.rstrip('/')
            # Remove www.
            url = url.replace('www.', '')
            # Lowercase
            return url.lower()
        
        for query in search_queries[:2]:  # Limit to 2 queries
            queries_attempted.append(query)
            
            # Try each provider until we get results
            for provider in self.providers:
                if not provider.is_available():
                    continue
                
                results = provider.search(query, max_results=3)
                
                if results:
                    # Deduplicate by normalized URL
                    unique_results = []
                    for result in results:
                        url = result.get('url', '')
                        if url:
                            normalized = normalize_url(url)
                            if normalized not in seen_urls:
                                seen_urls.add(normalized)
                                unique_results.append(result)
                    
                    all_sources.extend(unique_results)
                    print(f"✓ {provider.__class__.__name__} found {len(unique_results)} unique results for '{query}'")
                    break  # Got results, no need to try other providers for this query
                else:
                    print(f"✗ {provider.__class__.__name__} found no results for '{query}'")
        
        return {
            "enrichment_performed": len(all_sources) > 0,
            "sources_found": all_sources[:5],  # Top 5 unique results total
            "search_terms": queries_attempted,
            "message": f"Found {len(all_sources)} external sources" if all_sources else "No external sources found"
        }


